
нам писать лапидарный, структурированный и повторно используемый код.

Вскоре стало понятно, что возможность создавать повторно используемые бизнес компоненты это заблуждение. Каждый бизнес отличается от всех остальных, даже в одной отрасли. Каждый похожий проект работает по слишком специфичной бизнес логике.

Единственный способ сделать повторно используемые бизнес компоненты на этом уровне — сделать их сверх-настраиваемыми путём добавления таких штук как движки правил и встраиваемые языки.






Нарушение инкапсуляции


.b2 .b1__e1




# Способы модификации блока

БЭМ пропагандирует создание повторно используемых компонентов. Но каждый проект отличается от всех остальных, даже страницы в пределах одного портала будут иметь одинаковый набор компонентов, но при этом выглядеть и вести себя будут совершенно иначе. 

Поэтому есть библиотеки универсальных блоков, которые в БЭМ можно изменять различными способами:

* [Модификатором](#Модификатором)
* [Контекстом](#Контекстом)
* [Уровнем переопределения](#Уровнем-переопределения)
* [Миксом](#Миксом)

## Модификатором

Блоку/элементу добавляется модификатор и изменение блока/элемента описывается в коде этого модификатора.

Примеры

По умолчанию фон у попапа осутствует.

Transparent b-popup
Добавление модификатора theme блоку b-popup добавляет ему фон.
theme=yellow добавляет фон желтого цвета:

Yellow background modificator for b-popup block
theme=black добавляет фон черного цвета:

Black background modificator for b-popup block
У блока может быть одновременно несколько модификаторов.

Примеры

Модификатор theme — отвечает за фон попапа. Модификатор direction — отвечает за направление отображения попапа.

theme=yellow и direction=left — попап желтого цвета открывается влево:

Left direction modificator for b-popup block
theme=yellow и direction=right — попап желтого цвета открывается вправо:

Right direction modificator for b-poup block
Модификатор блока может изменять структуру блока (например, добавлять/удалять элементы) или его реализацию.

Пример
Модификатор has-close=yes — добавляет элемент «закрывающий крестик». Добавляет отступы блоку, освобождая место крестика.

Modificator for adding close icon to b-popup



## Контекстом

Блок при размещении в другом блоке может менять свой внешний вид или поведение.

Пример
Цвет текста вложенного блока меняется с зеленого на красный, если он помещен в блок с синим фоном с красными буквами.

Примеры

Переключатель языков (b-lang-switcher)

Language switcher block
Переключатель языков (b-lang-switcher) в подвале страницы (b-foot), уменьшается размер шрифта.

b-lang-switcher with small text


## Уровнем переопределения

Изменения создаются на следующем уровне переопределения и добавляют или изменяют функциональность блока.

Пример
Блок может выглядеть на разных проектах по-разному. При этом его общая часть лежит в одном файле (например, в репозитории фреймворка), а частная для проекта в другом (в репозитории проекта). Блок доопределяется дополнительными проектными файлами.

Модификация уровнем переопределения используется, например, в тестовом проекте bem-bl-test, где в папке blocks содержится код, доопределяющий поведение блока b-link. Это позволяет изменить основную реализацию блока (из библиотеки bem-bl) под нужды проекта.


## Миксом





1. Переопределения на уровнях
Если нам нужно, на некоторой странице иметь некий superInput, который чем-то отличается от базового input, то нам не обязательно именно придумывать новое имя и новый блок. Можно создать pages/index/blocks/input/input.js и положить туда BEM.DOM.decl('input', ... тут декларация полей и методов ...), эта декларация будет себя вести в точности как наследник базового blocks/input/input.js, т.е. будут доступны правильные this.__base() и this.__self.

2. Модификаторы
Поведение superInput базирующееся на базовом input можно представить как модификатор, например с именем type и значением super. В файле blocks/input/_type/input_type_super.js (который, кстати, можно создать командой bem create mod -l blocks -b input type -v super -T js) нужно написать BEM.DOM.decl({ block: 'input', modName: 'type', modVal: 'super'}, ... тут декларация полей и методов ...). Декларация полей и методов для модификатора также ведёт себя как наследник от базового класса, т.е. в методах доступны правильные this.__base() и this.__self.

3. Миксы
Мы можем выражать поведение элементов на странице с помощью смешивания нескольких БЭМ-сущностей на одной DOM-ноде. В HTML-е это будет выглядеть примерно так: . В BEMJSON так: { block: 'input', mix: [ { block: 'super-input' } ] }. После этого в коде блока blocks/super-input/super-input.js нет необходимости делать baseBlock, зато можно получить доступ к input с помощью метода this.findBlockOn('input') (документация в JSDoc).

4. Композиция блоков
Наконец можно просто использовать блок в составе другого блока, тут больше подходит пример с input и superForm. Можно вложить input внутрь superForm и из кода blocks/super-form/super-form.js можно будет получить доступ к input с помощью метода this.findBlockInside('input') (документация в JSDoc) и this.findBlocksInside('input') (документация в JSDoc).


Наследование в i-bem.js с помощью baseBlock мы реализовали скорее для полноты API и для того, чтобы было удобно делат некоторые i-* блоки, т.е. для функциональности внутри технологии JS. Этот способ не очень подходит для повторного использования БЭМ-сущностей в пределах всех технологий.

P.S. Так же рекомендую почитать критику объектно-ориентированного подхода вообще, например http://habrahabr.ru/post/143620/ .
