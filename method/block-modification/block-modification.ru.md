# Способы модификации блока

БЭМ-методология пердполагает создание повторно используемых компонентов. Но каждый проект отличается от всех остальных, даже страницы в пределах одного портала содержат одинаковые компоненты, которые выглядят и ведут себя по-разному в зависимости от контекста.

Поэтому есть библиотеки универсальных блоков, которые в БЭМ можно изменять различными способами:

* [Модификатором](#Модификатором)
* [Контекстом](#Контекстом)
* [Уровнем переопределения](#Уровнем-переопределения)
* [Миксом](#Миксом)

Важно, что ни в одном из способов нет необходимости копровать код блока, а затем изменять его.

## Модификатором

Блоку добавляется модификатор. Код модификатора описывает изменения блока.

Модификатор может изменять:
* [внешний вид блока](#Меняем-внешний-вид-блока)
* [поведение блока](#Меняем-поведение-блока)
* [структуру блока](#Меняем-структуру-блока) (например, добавлять или удалять элементы)

У блока может быть одновременно несколько модификаторов.

> Элементы блока можно таже изменять с помощью модификатора.

### Примеры

#### Меняем внешний вид блока 

```files
project/
	blocks/
		popup/
			popup.js
			popup.css
```

По умолчанию фон у попапа осутствует.

```css
.popup{
	bacground='none'
}
```

```html
    <!-- Блок popup -->
    <div class="popup">...</div>
```

![Transparent popup]()

Добавим блоку модификатор `theme`, который создаст фон.

Модификатор `theme` в значении `sun` добавляет фон желтого цвета:

```files
project/
	blocks/
		popup/
			popup.js
			popup.css
			_theme/
				popup_theme_sun.css
```

```html
    <!-- Блок popup -->
    <div class="popup popup_theme_sun">...</div>
```

![Yellow background modificator for popup block]()

Модификатор `theme` в значении `forest` добавляет фон зеленого цвета:

```html
    <!-- Блок popup -->
    <div class="popup popup_theme_forest">...</div>
```

![Green background modificator for popup block]()


#### Меняем поведение блока

Модификатор direction — отвечает за направление отображения попапа.

Модификатор `direction` в значении `left` открывает попап влево:

```html
    <!-- Блок popup -->
    <div class="popup popup_direction_left">...</div>
```

![Left direction modificator for popup block]()

Модификатор `direction` в значении `right` открывает попап вправо:

```html
    <!-- Блок popup -->
    <div class="popup popup_direction_right">...</div>
```

![Right direction modificator for popup block]()

#### Меняем структуру блока

Добавим модификатор `has-close` в значении `true`. У блока появляется элемент «закрывающий крестик». Также модификатор добавляет отступы блоку, освобождая место для крестика.

```html
    <!-- Блок popup -->
    <div class="popup popup_has-close">...</div>
```

> [Правила описания булевых модификаторов](https://ru.bem.info/methodology/naming-convention/#Модификатор-блока)

![Modificator for adding close icon to popup]()

#### Добавляем несколько модификаторов 

Модификатор `theme` отвечает за фон попапа. Модификатор `direction` — за направление отображения попапа.

Добавим модификтаоры:

* `theme` в значении `sun`;
* `direction` в значении `left`. 

```html
    <!-- Блок popup -->
    <div class="popup popup_theme_sun popup_direction_left">...</div>
```

Попап откроется влево и будет иметь желтый фон.

![Left direction modificator for yellow popup block]()


## Контекстом

Блок при размещении в другом блоке может менять свой внешний вид или поведение.

Пример
Цвет текста вложенного блока меняется с зеленого на красный, если он помещен в блок с синим фоном с красными буквами.

Примеры

Переключатель языков (b-lang-switcher)

Language switcher block
Переключатель языков (b-lang-switcher) в подвале страницы (b-foot), уменьшается размер шрифта.

b-lang-switcher with small text


## Уровнем переопределения

Изменения создаются на следующем уровне переопределения и добавляют или изменяют функциональность блока.

Пример
Блок может выглядеть на разных проектах по-разному. При этом его общая часть лежит в одном файле (например, в репозитории фреймворка), а частная для проекта в другом (в репозитории проекта). Блок доопределяется дополнительными проектными файлами.

Модификация уровнем переопределения используется, например, в тестовом проекте bem-bl-test, где в папке blocks содержится код, доопределяющий поведение блока b-link. Это позволяет изменить основную реализацию блока (из библиотеки bem-bl) под нужды проекта.


## Миксом





1. Переопределения на уровнях
Если нам нужно, на некоторой странице иметь некий superInput, который чем-то отличается от базового input, то нам не обязательно именно придумывать новое имя и новый блок. Можно создать pages/index/blocks/input/input.js и положить туда BEM.DOM.decl('input', ... тут декларация полей и методов ...), эта декларация будет себя вести в точности как наследник базового blocks/input/input.js, т.е. будут доступны правильные this.__base() и this.__self.

2. Модификаторы
Поведение superInput базирующееся на базовом input можно представить как модификатор, например с именем type и значением super. В файле blocks/input/_type/input_type_super.js (который, кстати, можно создать командой bem create mod -l blocks -b input type -v super -T js) нужно написать BEM.DOM.decl({ block: 'input', modName: 'type', modVal: 'super'}, ... тут декларация полей и методов ...). Декларация полей и методов для модификатора также ведёт себя как наследник от базового класса, т.е. в методах доступны правильные this.__base() и this.__self.

3. Миксы
Мы можем выражать поведение элементов на странице с помощью смешивания нескольких БЭМ-сущностей на одной DOM-ноде. В HTML-е это будет выглядеть примерно так: . В BEMJSON так: { block: 'input', mix: [ { block: 'super-input' } ] }. После этого в коде блока blocks/super-input/super-input.js нет необходимости делать baseBlock, зато можно получить доступ к input с помощью метода this.findBlockOn('input') (документация в JSDoc).

4. Композиция блоков
Наконец можно просто использовать блок в составе другого блока, тут больше подходит пример с input и superForm. Можно вложить input внутрь superForm и из кода blocks/super-form/super-form.js можно будет получить доступ к input с помощью метода this.findBlockInside('input') (документация в JSDoc) и this.findBlocksInside('input') (документация в JSDoc).


Наследование в i-bem.js с помощью baseBlock мы реализовали скорее для полноты API и для того, чтобы было удобно делат некоторые i-* блоки, т.е. для функциональности внутри технологии JS. Этот способ не очень подходит для повторного использования БЭМ-сущностей в пределах всех технологий.

P.S. Так же рекомендую почитать критику объектно-ориентированного подхода вообще, например http://habrahabr.ru/post/143620/ .



нам писать лапидарный, структурированный и повторно используемый код.

Вскоре стало понятно, что возможность создавать повторно используемые бизнес компоненты это заблуждение. Каждый бизнес отличается от всех остальных, даже в одной отрасли. Каждый похожий проект работает по слишком специфичной бизнес логике.

Единственный способ сделать повторно используемые бизнес компоненты на этом уровне — сделать их сверх-настраиваемыми путём добавления таких штук как движки правил и встраиваемые языки.






Нарушение инкапсуляции


.b2 .b1__e1



